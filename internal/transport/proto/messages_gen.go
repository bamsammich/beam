// Code generated by github.com/tinylib/msgp DO NOT EDIT.

package proto

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *AckResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z AckResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AckResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AckResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AckResp) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ApplyDeltaReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "basis_rel_path":
			z.BasisRelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BasisRelPath")
				return
			}
		case "temp_rel_path":
			z.TempRelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "TempRelPath")
				return
			}
		case "ops":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Ops")
				return
			}
			if cap(z.Ops) >= int(zb0002) {
				z.Ops = (z.Ops)[:zb0002]
			} else {
				z.Ops = make([]DeltaOpMsg, zb0002)
			}
			for za0001 := range z.Ops {
				err = z.Ops[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Ops", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ApplyDeltaReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "basis_rel_path"
	err = en.Append(0x83, 0xae, 0x62, 0x61, 0x73, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.BasisRelPath)
	if err != nil {
		err = msgp.WrapError(err, "BasisRelPath")
		return
	}
	// write "temp_rel_path"
	err = en.Append(0xad, 0x74, 0x65, 0x6d, 0x70, 0x5f, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.TempRelPath)
	if err != nil {
		err = msgp.WrapError(err, "TempRelPath")
		return
	}
	// write "ops"
	err = en.Append(0xa3, 0x6f, 0x70, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Ops)))
	if err != nil {
		err = msgp.WrapError(err, "Ops")
		return
	}
	for za0001 := range z.Ops {
		err = z.Ops[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Ops", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ApplyDeltaReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "basis_rel_path"
	o = append(o, 0x83, 0xae, 0x62, 0x61, 0x73, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.BasisRelPath)
	// string "temp_rel_path"
	o = append(o, 0xad, 0x74, 0x65, 0x6d, 0x70, 0x5f, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.TempRelPath)
	// string "ops"
	o = append(o, 0xa3, 0x6f, 0x70, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Ops)))
	for za0001 := range z.Ops {
		o, err = z.Ops[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Ops", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ApplyDeltaReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "basis_rel_path":
			z.BasisRelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BasisRelPath")
				return
			}
		case "temp_rel_path":
			z.TempRelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TempRelPath")
				return
			}
		case "ops":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ops")
				return
			}
			if cap(z.Ops) >= int(zb0002) {
				z.Ops = (z.Ops)[:zb0002]
			} else {
				z.Ops = make([]DeltaOpMsg, zb0002)
			}
			for za0001 := range z.Ops {
				bts, err = z.Ops[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ops", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ApplyDeltaReq) Msgsize() (s int) {
	s = 1 + 15 + msgp.StringPrefixSize + len(z.BasisRelPath) + 14 + msgp.StringPrefixSize + len(z.TempRelPath) + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.Ops {
		s += z.Ops[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ApplyDeltaResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bytes_written":
			z.BytesWritten, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BytesWritten")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ApplyDeltaResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "bytes_written"
	err = en.Append(0x81, 0xad, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BytesWritten)
	if err != nil {
		err = msgp.WrapError(err, "BytesWritten")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ApplyDeltaResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "bytes_written"
	o = append(o, 0x81, 0xad, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e)
	o = msgp.AppendInt64(o, z.BytesWritten)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ApplyDeltaResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bytes_written":
			z.BytesWritten, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesWritten")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ApplyDeltaResp) Msgsize() (s int) {
	s = 1 + 14 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BlockSignatureMsg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "index":
			z.Index, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "offset":
			z.Offset, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Offset")
				return
			}
		case "weak_hash":
			z.WeakHash, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WeakHash")
				return
			}
		case "strong_hash":
			z.StrongHash, err = dc.ReadBytes(z.StrongHash)
			if err != nil {
				err = msgp.WrapError(err, "StrongHash")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BlockSignatureMsg) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "index"
	err = en.Append(0x84, 0xa5, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Index)
	if err != nil {
		err = msgp.WrapError(err, "Index")
		return
	}
	// write "offset"
	err = en.Append(0xa6, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Offset)
	if err != nil {
		err = msgp.WrapError(err, "Offset")
		return
	}
	// write "weak_hash"
	err = en.Append(0xa9, 0x77, 0x65, 0x61, 0x6b, 0x5f, 0x68, 0x61, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.WeakHash)
	if err != nil {
		err = msgp.WrapError(err, "WeakHash")
		return
	}
	// write "strong_hash"
	err = en.Append(0xab, 0x73, 0x74, 0x72, 0x6f, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.StrongHash)
	if err != nil {
		err = msgp.WrapError(err, "StrongHash")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BlockSignatureMsg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "index"
	o = append(o, 0x84, 0xa5, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.Index)
	// string "offset"
	o = append(o, 0xa6, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74)
	o = msgp.AppendInt64(o, z.Offset)
	// string "weak_hash"
	o = append(o, 0xa9, 0x77, 0x65, 0x61, 0x6b, 0x5f, 0x68, 0x61, 0x73, 0x68)
	o = msgp.AppendUint64(o, z.WeakHash)
	// string "strong_hash"
	o = append(o, 0xab, 0x73, 0x74, 0x72, 0x6f, 0x6e, 0x67, 0x5f, 0x68, 0x61, 0x73, 0x68)
	o = msgp.AppendBytes(o, z.StrongHash)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlockSignatureMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "index":
			z.Index, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "offset":
			z.Offset, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offset")
				return
			}
		case "weak_hash":
			z.WeakHash, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeakHash")
				return
			}
		case "strong_hash":
			z.StrongHash, bts, err = msgp.ReadBytesBytes(bts, z.StrongHash)
			if err != nil {
				err = msgp.WrapError(err, "StrongHash")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlockSignatureMsg) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 7 + msgp.Int64Size + 10 + msgp.Uint64Size + 12 + msgp.BytesPrefixSize + len(z.StrongHash)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CapsReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CapsReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CapsReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CapsReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CapsReq) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CapsResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sparse_detect":
			z.SparseDetect, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "SparseDetect")
				return
			}
		case "hardlinks":
			z.Hardlinks, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Hardlinks")
				return
			}
		case "xattrs":
			z.Xattrs, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Xattrs")
				return
			}
		case "atomic_rename":
			z.AtomicRename, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AtomicRename")
				return
			}
		case "fast_copy":
			z.FastCopy, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "FastCopy")
				return
			}
		case "native_hash":
			z.NativeHash, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "NativeHash")
				return
			}
		case "delta_transfer":
			z.DeltaTransfer, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "DeltaTransfer")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CapsResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "sparse_detect"
	err = en.Append(0x87, 0xad, 0x73, 0x70, 0x61, 0x72, 0x73, 0x65, 0x5f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.SparseDetect)
	if err != nil {
		err = msgp.WrapError(err, "SparseDetect")
		return
	}
	// write "hardlinks"
	err = en.Append(0xa9, 0x68, 0x61, 0x72, 0x64, 0x6c, 0x69, 0x6e, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Hardlinks)
	if err != nil {
		err = msgp.WrapError(err, "Hardlinks")
		return
	}
	// write "xattrs"
	err = en.Append(0xa6, 0x78, 0x61, 0x74, 0x74, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Xattrs)
	if err != nil {
		err = msgp.WrapError(err, "Xattrs")
		return
	}
	// write "atomic_rename"
	err = en.Append(0xad, 0x61, 0x74, 0x6f, 0x6d, 0x69, 0x63, 0x5f, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AtomicRename)
	if err != nil {
		err = msgp.WrapError(err, "AtomicRename")
		return
	}
	// write "fast_copy"
	err = en.Append(0xa9, 0x66, 0x61, 0x73, 0x74, 0x5f, 0x63, 0x6f, 0x70, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBool(z.FastCopy)
	if err != nil {
		err = msgp.WrapError(err, "FastCopy")
		return
	}
	// write "native_hash"
	err = en.Append(0xab, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x68, 0x61, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteBool(z.NativeHash)
	if err != nil {
		err = msgp.WrapError(err, "NativeHash")
		return
	}
	// write "delta_transfer"
	err = en.Append(0xae, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.DeltaTransfer)
	if err != nil {
		err = msgp.WrapError(err, "DeltaTransfer")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CapsResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "sparse_detect"
	o = append(o, 0x87, 0xad, 0x73, 0x70, 0x61, 0x72, 0x73, 0x65, 0x5f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74)
	o = msgp.AppendBool(o, z.SparseDetect)
	// string "hardlinks"
	o = append(o, 0xa9, 0x68, 0x61, 0x72, 0x64, 0x6c, 0x69, 0x6e, 0x6b, 0x73)
	o = msgp.AppendBool(o, z.Hardlinks)
	// string "xattrs"
	o = append(o, 0xa6, 0x78, 0x61, 0x74, 0x74, 0x72, 0x73)
	o = msgp.AppendBool(o, z.Xattrs)
	// string "atomic_rename"
	o = append(o, 0xad, 0x61, 0x74, 0x6f, 0x6d, 0x69, 0x63, 0x5f, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendBool(o, z.AtomicRename)
	// string "fast_copy"
	o = append(o, 0xa9, 0x66, 0x61, 0x73, 0x74, 0x5f, 0x63, 0x6f, 0x70, 0x79)
	o = msgp.AppendBool(o, z.FastCopy)
	// string "native_hash"
	o = append(o, 0xab, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x68, 0x61, 0x73, 0x68)
	o = msgp.AppendBool(o, z.NativeHash)
	// string "delta_transfer"
	o = append(o, 0xae, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72)
	o = msgp.AppendBool(o, z.DeltaTransfer)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CapsResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sparse_detect":
			z.SparseDetect, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SparseDetect")
				return
			}
		case "hardlinks":
			z.Hardlinks, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hardlinks")
				return
			}
		case "xattrs":
			z.Xattrs, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Xattrs")
				return
			}
		case "atomic_rename":
			z.AtomicRename, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AtomicRename")
				return
			}
		case "fast_copy":
			z.FastCopy, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FastCopy")
				return
			}
		case "native_hash":
			z.NativeHash, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NativeHash")
				return
			}
		case "delta_transfer":
			z.DeltaTransfer, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeltaTransfer")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CapsResp) Msgsize() (s int) {
	s = 1 + 14 + msgp.BoolSize + 10 + msgp.BoolSize + 7 + msgp.BoolSize + 14 + msgp.BoolSize + 10 + msgp.BoolSize + 12 + msgp.BoolSize + 15 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ComputeSignatureReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "file_size":
			z.FileSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FileSize")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ComputeSignatureReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "rel_path"
	err = en.Append(0x82, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	// write "file_size"
	err = en.Append(0xa9, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.FileSize)
	if err != nil {
		err = msgp.WrapError(err, "FileSize")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ComputeSignatureReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "rel_path"
	o = append(o, 0x82, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	// string "file_size"
	o = append(o, 0xa9, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt64(o, z.FileSize)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ComputeSignatureReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "file_size":
			z.FileSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileSize")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ComputeSignatureReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath) + 10 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ComputeSignatureResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "block_size":
			z.BlockSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BlockSize")
				return
			}
		case "signatures":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Signatures")
				return
			}
			if cap(z.Signatures) >= int(zb0002) {
				z.Signatures = (z.Signatures)[:zb0002]
			} else {
				z.Signatures = make([]BlockSignatureMsg, zb0002)
			}
			for za0001 := range z.Signatures {
				err = z.Signatures[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Signatures", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ComputeSignatureResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "block_size"
	err = en.Append(0x82, 0xaa, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BlockSize)
	if err != nil {
		err = msgp.WrapError(err, "BlockSize")
		return
	}
	// write "signatures"
	err = en.Append(0xaa, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Signatures)))
	if err != nil {
		err = msgp.WrapError(err, "Signatures")
		return
	}
	for za0001 := range z.Signatures {
		err = z.Signatures[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Signatures", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ComputeSignatureResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "block_size"
	o = append(o, 0x82, 0xaa, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.BlockSize)
	// string "signatures"
	o = append(o, 0xaa, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Signatures)))
	for za0001 := range z.Signatures {
		o, err = z.Signatures[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Signatures", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ComputeSignatureResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "block_size":
			z.BlockSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlockSize")
				return
			}
		case "signatures":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signatures")
				return
			}
			if cap(z.Signatures) >= int(zb0002) {
				z.Signatures = (z.Signatures)[:zb0002]
			} else {
				z.Signatures = make([]BlockSignatureMsg, zb0002)
			}
			for za0001 := range z.Signatures {
				bts, err = z.Signatures[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Signatures", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ComputeSignatureResp) Msgsize() (s int) {
	s = 1 + 11 + msgp.IntSize + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.Signatures {
		s += z.Signatures[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CreateTempReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "perm":
			z.Perm, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Perm")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CreateTempReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "rel_path"
	err = en.Append(0x82, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	// write "perm"
	err = en.Append(0xa4, 0x70, 0x65, 0x72, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Perm)
	if err != nil {
		err = msgp.WrapError(err, "Perm")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CreateTempReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "rel_path"
	o = append(o, 0x82, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	// string "perm"
	o = append(o, 0xa4, 0x70, 0x65, 0x72, 0x6d)
	o = msgp.AppendUint32(o, z.Perm)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CreateTempReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "perm":
			z.Perm, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Perm")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CreateTempReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath) + 5 + msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CreateTempResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "handle":
			z.Handle, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Handle")
				return
			}
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CreateTempResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "handle"
	err = en.Append(0x82, 0xa6, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Handle)
	if err != nil {
		err = msgp.WrapError(err, "Handle")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CreateTempResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "handle"
	o = append(o, 0x82, 0xa6, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Handle)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CreateTempResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "handle":
			z.Handle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Handle")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CreateTempResp) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Handle) + 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DeltaOpMsg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "block_idx":
			z.BlockIdx, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BlockIdx")
				return
			}
		case "offset":
			z.Offset, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Offset")
				return
			}
		case "length":
			z.Length, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Length")
				return
			}
		case "literal":
			z.Literal, err = dc.ReadBytes(z.Literal)
			if err != nil {
				err = msgp.WrapError(err, "Literal")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DeltaOpMsg) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "block_idx"
	err = en.Append(0x84, 0xa9, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x69, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BlockIdx)
	if err != nil {
		err = msgp.WrapError(err, "BlockIdx")
		return
	}
	// write "offset"
	err = en.Append(0xa6, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Offset)
	if err != nil {
		err = msgp.WrapError(err, "Offset")
		return
	}
	// write "length"
	err = en.Append(0xa6, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Length)
	if err != nil {
		err = msgp.WrapError(err, "Length")
		return
	}
	// write "literal"
	err = en.Append(0xa7, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Literal)
	if err != nil {
		err = msgp.WrapError(err, "Literal")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DeltaOpMsg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "block_idx"
	o = append(o, 0x84, 0xa9, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x69, 0x64, 0x78)
	o = msgp.AppendInt(o, z.BlockIdx)
	// string "offset"
	o = append(o, 0xa6, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74)
	o = msgp.AppendInt64(o, z.Offset)
	// string "length"
	o = append(o, 0xa6, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68)
	o = msgp.AppendInt(o, z.Length)
	// string "literal"
	o = append(o, 0xa7, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c)
	o = msgp.AppendBytes(o, z.Literal)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DeltaOpMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "block_idx":
			z.BlockIdx, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlockIdx")
				return
			}
		case "offset":
			z.Offset, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offset")
				return
			}
		case "length":
			z.Length, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Length")
				return
			}
		case "literal":
			z.Literal, bts, err = msgp.ReadBytesBytes(bts, z.Literal)
			if err != nil {
				err = msgp.WrapError(err, "Literal")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DeltaOpMsg) Msgsize() (s int) {
	s = 1 + 10 + msgp.IntSize + 7 + msgp.Int64Size + 7 + msgp.IntSize + 8 + msgp.BytesPrefixSize + len(z.Literal)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ErrorResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "message":
			z.Message, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "code":
			z.Code, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ErrorResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "message"
	err = en.Append(0x82, 0xa7, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Message)
	if err != nil {
		err = msgp.WrapError(err, "Message")
		return
	}
	// write "code"
	err = en.Append(0xa4, 0x63, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Code)
	if err != nil {
		err = msgp.WrapError(err, "Code")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ErrorResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "message"
	o = append(o, 0x82, 0xa7, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.Message)
	// string "code"
	o = append(o, 0xa4, 0x63, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.Code)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ErrorResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "message":
			z.Message, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "code":
			z.Code, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ErrorResp) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Message) + 5 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FileEntryMsg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "size":
			z.Size, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "mode":
			z.Mode, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "mod_time":
			z.ModTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ModTime")
				return
			}
		case "acc_time":
			z.AccTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "AccTime")
				return
			}
		case "is_dir":
			z.IsDir, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsDir")
				return
			}
		case "is_symlink":
			z.IsSymlink, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsSymlink")
				return
			}
		case "link_target":
			z.LinkTarget, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LinkTarget")
				return
			}
		case "uid":
			z.UID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "gid":
			z.GID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "nlink":
			z.Nlink, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Nlink")
				return
			}
		case "dev":
			z.Dev, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Dev")
				return
			}
		case "ino":
			z.Ino, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Ino")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *FileEntryMsg) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 13
	// write "rel_path"
	err = en.Append(0x8d, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	// write "size"
	err = en.Append(0xa4, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Size)
	if err != nil {
		err = msgp.WrapError(err, "Size")
		return
	}
	// write "mode"
	err = en.Append(0xa4, 0x6d, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Mode)
	if err != nil {
		err = msgp.WrapError(err, "Mode")
		return
	}
	// write "mod_time"
	err = en.Append(0xa8, 0x6d, 0x6f, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ModTime)
	if err != nil {
		err = msgp.WrapError(err, "ModTime")
		return
	}
	// write "acc_time"
	err = en.Append(0xa8, 0x61, 0x63, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.AccTime)
	if err != nil {
		err = msgp.WrapError(err, "AccTime")
		return
	}
	// write "is_dir"
	err = en.Append(0xa6, 0x69, 0x73, 0x5f, 0x64, 0x69, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsDir)
	if err != nil {
		err = msgp.WrapError(err, "IsDir")
		return
	}
	// write "is_symlink"
	err = en.Append(0xaa, 0x69, 0x73, 0x5f, 0x73, 0x79, 0x6d, 0x6c, 0x69, 0x6e, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsSymlink)
	if err != nil {
		err = msgp.WrapError(err, "IsSymlink")
		return
	}
	// write "link_target"
	err = en.Append(0xab, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.LinkTarget)
	if err != nil {
		err = msgp.WrapError(err, "LinkTarget")
		return
	}
	// write "uid"
	err = en.Append(0xa3, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.UID)
	if err != nil {
		err = msgp.WrapError(err, "UID")
		return
	}
	// write "gid"
	err = en.Append(0xa3, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.GID)
	if err != nil {
		err = msgp.WrapError(err, "GID")
		return
	}
	// write "nlink"
	err = en.Append(0xa5, 0x6e, 0x6c, 0x69, 0x6e, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Nlink)
	if err != nil {
		err = msgp.WrapError(err, "Nlink")
		return
	}
	// write "dev"
	err = en.Append(0xa3, 0x64, 0x65, 0x76)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Dev)
	if err != nil {
		err = msgp.WrapError(err, "Dev")
		return
	}
	// write "ino"
	err = en.Append(0xa3, 0x69, 0x6e, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Ino)
	if err != nil {
		err = msgp.WrapError(err, "Ino")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileEntryMsg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "rel_path"
	o = append(o, 0x8d, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	// string "size"
	o = append(o, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt64(o, z.Size)
	// string "mode"
	o = append(o, 0xa4, 0x6d, 0x6f, 0x64, 0x65)
	o = msgp.AppendUint32(o, z.Mode)
	// string "mod_time"
	o = append(o, 0xa8, 0x6d, 0x6f, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.ModTime)
	// string "acc_time"
	o = append(o, 0xa8, 0x61, 0x63, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.AccTime)
	// string "is_dir"
	o = append(o, 0xa6, 0x69, 0x73, 0x5f, 0x64, 0x69, 0x72)
	o = msgp.AppendBool(o, z.IsDir)
	// string "is_symlink"
	o = append(o, 0xaa, 0x69, 0x73, 0x5f, 0x73, 0x79, 0x6d, 0x6c, 0x69, 0x6e, 0x6b)
	o = msgp.AppendBool(o, z.IsSymlink)
	// string "link_target"
	o = append(o, 0xab, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74)
	o = msgp.AppendString(o, z.LinkTarget)
	// string "uid"
	o = append(o, 0xa3, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.UID)
	// string "gid"
	o = append(o, 0xa3, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.GID)
	// string "nlink"
	o = append(o, 0xa5, 0x6e, 0x6c, 0x69, 0x6e, 0x6b)
	o = msgp.AppendUint32(o, z.Nlink)
	// string "dev"
	o = append(o, 0xa3, 0x64, 0x65, 0x76)
	o = msgp.AppendUint64(o, z.Dev)
	// string "ino"
	o = append(o, 0xa3, 0x69, 0x6e, 0x6f)
	o = msgp.AppendUint64(o, z.Ino)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileEntryMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "size":
			z.Size, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "mode":
			z.Mode, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "mod_time":
			z.ModTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModTime")
				return
			}
		case "acc_time":
			z.AccTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AccTime")
				return
			}
		case "is_dir":
			z.IsDir, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsDir")
				return
			}
		case "is_symlink":
			z.IsSymlink, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsSymlink")
				return
			}
		case "link_target":
			z.LinkTarget, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LinkTarget")
				return
			}
		case "uid":
			z.UID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "gid":
			z.GID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "nlink":
			z.Nlink, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nlink")
				return
			}
		case "dev":
			z.Dev, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Dev")
				return
			}
		case "ino":
			z.Ino, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ino")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileEntryMsg) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath) + 5 + msgp.Int64Size + 5 + msgp.Uint32Size + 9 + msgp.Int64Size + 9 + msgp.Int64Size + 7 + msgp.BoolSize + 11 + msgp.BoolSize + 12 + msgp.StringPrefixSize + len(z.LinkTarget) + 4 + msgp.Uint32Size + 4 + msgp.Uint32Size + 6 + msgp.Uint32Size + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HandshakeReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "version":
			z.Version, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "capabilities":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Capabilities")
				return
			}
			if cap(z.Capabilities) >= int(zb0002) {
				z.Capabilities = (z.Capabilities)[:zb0002]
			} else {
				z.Capabilities = make([]string, zb0002)
			}
			for za0001 := range z.Capabilities {
				z.Capabilities[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Capabilities", za0001)
					return
				}
			}
		case "auth_token":
			z.AuthToken, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AuthToken")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HandshakeReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "version"
	err = en.Append(0x83, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "capabilities"
	err = en.Append(0xac, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Capabilities)))
	if err != nil {
		err = msgp.WrapError(err, "Capabilities")
		return
	}
	for za0001 := range z.Capabilities {
		err = en.WriteString(z.Capabilities[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Capabilities", za0001)
			return
		}
	}
	// write "auth_token"
	err = en.Append(0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.AuthToken)
	if err != nil {
		err = msgp.WrapError(err, "AuthToken")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HandshakeReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "version"
	o = append(o, 0x83, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Version)
	// string "capabilities"
	o = append(o, 0xac, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Capabilities)))
	for za0001 := range z.Capabilities {
		o = msgp.AppendString(o, z.Capabilities[za0001])
	}
	// string "auth_token"
	o = append(o, 0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.AuthToken)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HandshakeReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "version":
			z.Version, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "capabilities":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Capabilities")
				return
			}
			if cap(z.Capabilities) >= int(zb0002) {
				z.Capabilities = (z.Capabilities)[:zb0002]
			} else {
				z.Capabilities = make([]string, zb0002)
			}
			for za0001 := range z.Capabilities {
				z.Capabilities[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Capabilities", za0001)
					return
				}
			}
		case "auth_token":
			z.AuthToken, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AuthToken")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HandshakeReq) Msgsize() (s int) {
	s = 1 + 8 + msgp.IntSize + 13 + msgp.ArrayHeaderSize
	for za0001 := range z.Capabilities {
		s += msgp.StringPrefixSize + len(z.Capabilities[za0001])
	}
	s += 11 + msgp.StringPrefixSize + len(z.AuthToken)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HandshakeResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "version":
			z.Version, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "capabilities":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Capabilities")
				return
			}
			if cap(z.Capabilities) >= int(zb0002) {
				z.Capabilities = (z.Capabilities)[:zb0002]
			} else {
				z.Capabilities = make([]string, zb0002)
			}
			for za0001 := range z.Capabilities {
				z.Capabilities[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Capabilities", za0001)
					return
				}
			}
		case "root":
			z.Root, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Root")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HandshakeResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "version"
	err = en.Append(0x83, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "capabilities"
	err = en.Append(0xac, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Capabilities)))
	if err != nil {
		err = msgp.WrapError(err, "Capabilities")
		return
	}
	for za0001 := range z.Capabilities {
		err = en.WriteString(z.Capabilities[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Capabilities", za0001)
			return
		}
	}
	// write "root"
	err = en.Append(0xa4, 0x72, 0x6f, 0x6f, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Root)
	if err != nil {
		err = msgp.WrapError(err, "Root")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HandshakeResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "version"
	o = append(o, 0x83, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Version)
	// string "capabilities"
	o = append(o, 0xac, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Capabilities)))
	for za0001 := range z.Capabilities {
		o = msgp.AppendString(o, z.Capabilities[za0001])
	}
	// string "root"
	o = append(o, 0xa4, 0x72, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.Root)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HandshakeResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "version":
			z.Version, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "capabilities":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Capabilities")
				return
			}
			if cap(z.Capabilities) >= int(zb0002) {
				z.Capabilities = (z.Capabilities)[:zb0002]
			} else {
				z.Capabilities = make([]string, zb0002)
			}
			for za0001 := range z.Capabilities {
				z.Capabilities[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Capabilities", za0001)
					return
				}
			}
		case "root":
			z.Root, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Root")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HandshakeResp) Msgsize() (s int) {
	s = 1 + 8 + msgp.IntSize + 13 + msgp.ArrayHeaderSize
	for za0001 := range z.Capabilities {
		s += msgp.StringPrefixSize + len(z.Capabilities[za0001])
	}
	s += 5 + msgp.StringPrefixSize + len(z.Root)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HashReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HashReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "rel_path"
	err = en.Append(0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HashReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "rel_path"
	o = append(o, 0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HashReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HashReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HashResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hash":
			z.Hash, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HashResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "hash"
	err = en.Append(0x81, 0xa4, 0x68, 0x61, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HashResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "hash"
	o = append(o, 0x81, 0xa4, 0x68, 0x61, 0x73, 0x68)
	o = msgp.AppendString(o, z.Hash)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HashResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "hash":
			z.Hash, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HashResp) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Hash)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LinkReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "old_rel":
			z.OldRel, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OldRel")
				return
			}
		case "new_rel":
			z.NewRel, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "NewRel")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z LinkReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "old_rel"
	err = en.Append(0x82, 0xa7, 0x6f, 0x6c, 0x64, 0x5f, 0x72, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.OldRel)
	if err != nil {
		err = msgp.WrapError(err, "OldRel")
		return
	}
	// write "new_rel"
	err = en.Append(0xa7, 0x6e, 0x65, 0x77, 0x5f, 0x72, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.NewRel)
	if err != nil {
		err = msgp.WrapError(err, "NewRel")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LinkReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "old_rel"
	o = append(o, 0x82, 0xa7, 0x6f, 0x6c, 0x64, 0x5f, 0x72, 0x65, 0x6c)
	o = msgp.AppendString(o, z.OldRel)
	// string "new_rel"
	o = append(o, 0xa7, 0x6e, 0x65, 0x77, 0x5f, 0x72, 0x65, 0x6c)
	o = msgp.AppendString(o, z.NewRel)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LinkReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "old_rel":
			z.OldRel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OldRel")
				return
			}
		case "new_rel":
			z.NewRel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NewRel")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LinkReq) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.OldRel) + 8 + msgp.StringPrefixSize + len(z.NewRel)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MatchBlocksReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "block_size":
			z.BlockSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BlockSize")
				return
			}
		case "signatures":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Signatures")
				return
			}
			if cap(z.Signatures) >= int(zb0002) {
				z.Signatures = (z.Signatures)[:zb0002]
			} else {
				z.Signatures = make([]BlockSignatureMsg, zb0002)
			}
			for za0001 := range z.Signatures {
				err = z.Signatures[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Signatures", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MatchBlocksReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "rel_path"
	err = en.Append(0x83, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	// write "block_size"
	err = en.Append(0xaa, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BlockSize)
	if err != nil {
		err = msgp.WrapError(err, "BlockSize")
		return
	}
	// write "signatures"
	err = en.Append(0xaa, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Signatures)))
	if err != nil {
		err = msgp.WrapError(err, "Signatures")
		return
	}
	for za0001 := range z.Signatures {
		err = z.Signatures[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Signatures", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MatchBlocksReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "rel_path"
	o = append(o, 0x83, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	// string "block_size"
	o = append(o, 0xaa, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.BlockSize)
	// string "signatures"
	o = append(o, 0xaa, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Signatures)))
	for za0001 := range z.Signatures {
		o, err = z.Signatures[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Signatures", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MatchBlocksReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "block_size":
			z.BlockSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlockSize")
				return
			}
		case "signatures":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signatures")
				return
			}
			if cap(z.Signatures) >= int(zb0002) {
				z.Signatures = (z.Signatures)[:zb0002]
			} else {
				z.Signatures = make([]BlockSignatureMsg, zb0002)
			}
			for za0001 := range z.Signatures {
				bts, err = z.Signatures[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Signatures", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MatchBlocksReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath) + 11 + msgp.IntSize + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.Signatures {
		s += z.Signatures[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MatchBlocksResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ops":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Ops")
				return
			}
			if cap(z.Ops) >= int(zb0002) {
				z.Ops = (z.Ops)[:zb0002]
			} else {
				z.Ops = make([]DeltaOpMsg, zb0002)
			}
			for za0001 := range z.Ops {
				err = z.Ops[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Ops", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MatchBlocksResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "ops"
	err = en.Append(0x81, 0xa3, 0x6f, 0x70, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Ops)))
	if err != nil {
		err = msgp.WrapError(err, "Ops")
		return
	}
	for za0001 := range z.Ops {
		err = z.Ops[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Ops", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MatchBlocksResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "ops"
	o = append(o, 0x81, 0xa3, 0x6f, 0x70, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Ops)))
	for za0001 := range z.Ops {
		o, err = z.Ops[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Ops", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MatchBlocksResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ops":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ops")
				return
			}
			if cap(z.Ops) >= int(zb0002) {
				z.Ops = (z.Ops)[:zb0002]
			} else {
				z.Ops = make([]DeltaOpMsg, zb0002)
			}
			for za0001 := range z.Ops {
				bts, err = z.Ops[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ops", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MatchBlocksResp) Msgsize() (s int) {
	s = 1 + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.Ops {
		s += z.Ops[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetadataOptsMsg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "mode":
			z.Mode, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "times":
			z.Times, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Times")
				return
			}
		case "owner":
			z.Owner, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "xattr":
			z.Xattr, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Xattr")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MetadataOptsMsg) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "mode"
	err = en.Append(0x84, 0xa4, 0x6d, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Mode)
	if err != nil {
		err = msgp.WrapError(err, "Mode")
		return
	}
	// write "times"
	err = en.Append(0xa5, 0x74, 0x69, 0x6d, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Times)
	if err != nil {
		err = msgp.WrapError(err, "Times")
		return
	}
	// write "owner"
	err = en.Append(0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Owner)
	if err != nil {
		err = msgp.WrapError(err, "Owner")
		return
	}
	// write "xattr"
	err = en.Append(0xa5, 0x78, 0x61, 0x74, 0x74, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Xattr)
	if err != nil {
		err = msgp.WrapError(err, "Xattr")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MetadataOptsMsg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "mode"
	o = append(o, 0x84, 0xa4, 0x6d, 0x6f, 0x64, 0x65)
	o = msgp.AppendBool(o, z.Mode)
	// string "times"
	o = append(o, 0xa5, 0x74, 0x69, 0x6d, 0x65, 0x73)
	o = msgp.AppendBool(o, z.Times)
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendBool(o, z.Owner)
	// string "xattr"
	o = append(o, 0xa5, 0x78, 0x61, 0x74, 0x74, 0x72)
	o = msgp.AppendBool(o, z.Xattr)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetadataOptsMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "mode":
			z.Mode, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "times":
			z.Times, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Times")
				return
			}
		case "owner":
			z.Owner, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "xattr":
			z.Xattr, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Xattr")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MetadataOptsMsg) Msgsize() (s int) {
	s = 1 + 5 + msgp.BoolSize + 6 + msgp.BoolSize + 6 + msgp.BoolSize + 6 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MkdirAllReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "perm":
			z.Perm, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Perm")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MkdirAllReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "rel_path"
	err = en.Append(0x82, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	// write "perm"
	err = en.Append(0xa4, 0x70, 0x65, 0x72, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Perm)
	if err != nil {
		err = msgp.WrapError(err, "Perm")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MkdirAllReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "rel_path"
	o = append(o, 0x82, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	// string "perm"
	o = append(o, 0xa4, 0x70, 0x65, 0x72, 0x6d)
	o = msgp.AppendUint32(o, z.Perm)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MkdirAllReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "perm":
			z.Perm, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Perm")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MkdirAllReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath) + 5 + msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OpenReadReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z OpenReadReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "rel_path"
	err = en.Append(0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z OpenReadReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "rel_path"
	o = append(o, 0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OpenReadReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OpenReadReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PingReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "seq":
			z.Seq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Seq")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PingReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "seq"
	err = en.Append(0x81, 0xa3, 0x73, 0x65, 0x71)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Seq)
	if err != nil {
		err = msgp.WrapError(err, "Seq")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PingReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "seq"
	o = append(o, 0x81, 0xa3, 0x73, 0x65, 0x71)
	o = msgp.AppendUint64(o, z.Seq)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PingReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "seq":
			z.Seq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Seq")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PingReq) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PongResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "seq":
			z.Seq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Seq")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PongResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "seq"
	err = en.Append(0x81, 0xa3, 0x73, 0x65, 0x71)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Seq)
	if err != nil {
		err = msgp.WrapError(err, "Seq")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PongResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "seq"
	o = append(o, 0x81, 0xa3, 0x73, 0x65, 0x71)
	o = msgp.AppendUint64(o, z.Seq)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PongResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "seq":
			z.Seq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Seq")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PongResp) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReadDataMsg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "data":
			z.Data, err = dc.ReadBytes(z.Data)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReadDataMsg) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "data"
	err = en.Append(0x81, 0xa4, 0x64, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReadDataMsg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "data"
	o = append(o, 0x81, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadDataMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "data":
			z.Data, bts, err = msgp.ReadBytesBytes(bts, z.Data)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReadDataMsg) Msgsize() (s int) {
	s = 1 + 5 + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReadDirReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ReadDirReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "rel_path"
	err = en.Append(0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ReadDirReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "rel_path"
	o = append(o, 0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadDirReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ReadDirReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReadDirResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "entries":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Entries")
				return
			}
			if cap(z.Entries) >= int(zb0002) {
				z.Entries = (z.Entries)[:zb0002]
			} else {
				z.Entries = make([]FileEntryMsg, zb0002)
			}
			for za0001 := range z.Entries {
				err = z.Entries[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Entries", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReadDirResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "entries"
	err = en.Append(0x81, 0xa7, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Entries)))
	if err != nil {
		err = msgp.WrapError(err, "Entries")
		return
	}
	for za0001 := range z.Entries {
		err = z.Entries[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Entries", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReadDirResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "entries"
	o = append(o, 0x81, 0xa7, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Entries)))
	for za0001 := range z.Entries {
		o, err = z.Entries[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Entries", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadDirResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "entries":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Entries")
				return
			}
			if cap(z.Entries) >= int(zb0002) {
				z.Entries = (z.Entries)[:zb0002]
			} else {
				z.Entries = make([]FileEntryMsg, zb0002)
			}
			for za0001 := range z.Entries {
				bts, err = z.Entries[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Entries", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReadDirResp) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Entries {
		s += z.Entries[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReadDone) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ReadDone) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ReadDone) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadDone) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ReadDone) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RemoveAllReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z RemoveAllReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "rel_path"
	err = en.Append(0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z RemoveAllReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "rel_path"
	o = append(o, 0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RemoveAllReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z RemoveAllReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RemoveReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z RemoveReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "rel_path"
	err = en.Append(0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z RemoveReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "rel_path"
	o = append(o, 0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RemoveReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z RemoveReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RenameReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "old_rel":
			z.OldRel, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OldRel")
				return
			}
		case "new_rel":
			z.NewRel, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "NewRel")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z RenameReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "old_rel"
	err = en.Append(0x82, 0xa7, 0x6f, 0x6c, 0x64, 0x5f, 0x72, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.OldRel)
	if err != nil {
		err = msgp.WrapError(err, "OldRel")
		return
	}
	// write "new_rel"
	err = en.Append(0xa7, 0x6e, 0x65, 0x77, 0x5f, 0x72, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.NewRel)
	if err != nil {
		err = msgp.WrapError(err, "NewRel")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z RenameReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "old_rel"
	o = append(o, 0x82, 0xa7, 0x6f, 0x6c, 0x64, 0x5f, 0x72, 0x65, 0x6c)
	o = msgp.AppendString(o, z.OldRel)
	// string "new_rel"
	o = append(o, 0xa7, 0x6e, 0x65, 0x77, 0x5f, 0x72, 0x65, 0x6c)
	o = msgp.AppendString(o, z.NewRel)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RenameReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "old_rel":
			z.OldRel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OldRel")
				return
			}
		case "new_rel":
			z.NewRel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NewRel")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z RenameReq) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.OldRel) + 8 + msgp.StringPrefixSize + len(z.NewRel)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetMetadataReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "entry":
			err = z.Entry.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		case "opts":
			err = z.Opts.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Opts")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SetMetadataReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "rel_path"
	err = en.Append(0x83, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	// write "entry"
	err = en.Append(0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	if err != nil {
		return
	}
	err = z.Entry.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Entry")
		return
	}
	// write "opts"
	err = en.Append(0xa4, 0x6f, 0x70, 0x74, 0x73)
	if err != nil {
		return
	}
	err = z.Opts.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Opts")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SetMetadataReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "rel_path"
	o = append(o, 0x83, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	// string "entry"
	o = append(o, 0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	o, err = z.Entry.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Entry")
		return
	}
	// string "opts"
	o = append(o, 0xa4, 0x6f, 0x70, 0x74, 0x73)
	o, err = z.Opts.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Opts")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetMetadataReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		case "entry":
			bts, err = z.Entry.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		case "opts":
			bts, err = z.Opts.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Opts")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SetMetadataReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath) + 6 + z.Entry.Msgsize() + 5 + z.Opts.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StatReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z StatReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "rel_path"
	err = en.Append(0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.RelPath)
	if err != nil {
		err = msgp.WrapError(err, "RelPath")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z StatReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "rel_path"
	o = append(o, 0x81, 0xa8, 0x72, 0x65, 0x6c, 0x5f, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.RelPath)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StatReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rel_path":
			z.RelPath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RelPath")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z StatReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.RelPath)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StatResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "entry":
			err = z.Entry.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *StatResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "entry"
	err = en.Append(0x81, 0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	if err != nil {
		return
	}
	err = z.Entry.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Entry")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StatResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "entry"
	o = append(o, 0x81, 0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	o, err = z.Entry.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Entry")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StatResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "entry":
			bts, err = z.Entry.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StatResp) Msgsize() (s int) {
	s = 1 + 6 + z.Entry.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SymlinkReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "target":
			z.Target, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Target")
				return
			}
		case "new_rel":
			z.NewRel, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "NewRel")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SymlinkReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "target"
	err = en.Append(0x82, 0xa6, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Target)
	if err != nil {
		err = msgp.WrapError(err, "Target")
		return
	}
	// write "new_rel"
	err = en.Append(0xa7, 0x6e, 0x65, 0x77, 0x5f, 0x72, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.NewRel)
	if err != nil {
		err = msgp.WrapError(err, "NewRel")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SymlinkReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "target"
	o = append(o, 0x82, 0xa6, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74)
	o = msgp.AppendString(o, z.Target)
	// string "new_rel"
	o = append(o, 0xa7, 0x6e, 0x65, 0x77, 0x5f, 0x72, 0x65, 0x6c)
	o = msgp.AppendString(o, z.NewRel)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SymlinkReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "target":
			z.Target, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Target")
				return
			}
		case "new_rel":
			z.NewRel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NewRel")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SymlinkReq) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Target) + 8 + msgp.StringPrefixSize + len(z.NewRel)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WalkEnd) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z WalkEnd) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WalkEnd) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WalkEnd) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WalkEnd) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WalkEntry) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "entry":
			err = z.Entry.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *WalkEntry) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "entry"
	err = en.Append(0x81, 0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	if err != nil {
		return
	}
	err = z.Entry.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Entry")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WalkEntry) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "entry"
	o = append(o, 0x81, 0xa5, 0x65, 0x6e, 0x74, 0x72, 0x79)
	o, err = z.Entry.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Entry")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WalkEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "entry":
			bts, err = z.Entry.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Entry")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WalkEntry) Msgsize() (s int) {
	s = 1 + 6 + z.Entry.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WalkReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z WalkReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WalkReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WalkReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WalkReq) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WriteDataMsg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "handle":
			z.Handle, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Handle")
				return
			}
		case "data":
			z.Data, err = dc.ReadBytes(z.Data)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *WriteDataMsg) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "handle"
	err = en.Append(0x82, 0xa6, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Handle)
	if err != nil {
		err = msgp.WrapError(err, "Handle")
		return
	}
	// write "data"
	err = en.Append(0xa4, 0x64, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WriteDataMsg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "handle"
	o = append(o, 0x82, 0xa6, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Handle)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WriteDataMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "handle":
			z.Handle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Handle")
				return
			}
		case "data":
			z.Data, bts, err = msgp.ReadBytesBytes(bts, z.Data)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WriteDataMsg) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Handle) + 5 + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WriteDoneReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "handle":
			z.Handle, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Handle")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z WriteDoneReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "handle"
	err = en.Append(0x81, 0xa6, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Handle)
	if err != nil {
		err = msgp.WrapError(err, "Handle")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WriteDoneReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "handle"
	o = append(o, 0x81, 0xa6, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Handle)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WriteDoneReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "handle":
			z.Handle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Handle")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WriteDoneReq) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Handle)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WriteDoneResp) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z WriteDoneResp) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WriteDoneResp) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WriteDoneResp) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WriteDoneResp) Msgsize() (s int) {
	s = 1
	return
}
